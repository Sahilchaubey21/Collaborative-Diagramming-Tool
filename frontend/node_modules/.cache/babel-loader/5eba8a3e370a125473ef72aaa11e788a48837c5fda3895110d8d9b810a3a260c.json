{"ast":null,"code":"var _jsxFileName = \"D:\\\\Downloads\\\\DRAW\\\\frontend\\\\src\\\\components\\\\Canvas.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect, useCallback, forwardRef, useImperativeHandle } from 'react';\nimport api from '../api';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst CANVAS_WIDTH = 800;\nconst CANVAS_HEIGHT = 600;\nconst TOOLS = {\n  PEN: 'pen',\n  LINE: 'line',\n  RECT: 'rect',\n  CIRCLE: 'circle',\n  TEXT: 'text',\n  SELECT: 'select'\n};\nconst ELEMENT_TYPES = {\n  PEN: 'pen',\n  LINE: 'line',\n  RECT: 'rect',\n  CIRCLE: 'circle',\n  TEXT: 'text',\n  IMAGE: 'image'\n};\nfunction drawLine(ctx, x0, y0, x1, y1, color = '#000', width = 2) {\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = width;\n  ctx.lineCap = 'round';\n  ctx.beginPath();\n  ctx.moveTo(x0, y0);\n  ctx.lineTo(x1, y1);\n  ctx.stroke();\n  ctx.restore();\n}\nfunction drawRect(ctx, x0, y0, x1, y1, color = '#000', width = 2, filled = false) {\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = width;\n  if (filled) {\n    ctx.fillStyle = color;\n    ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n  } else {\n    ctx.strokeRect(x0, y0, x1 - x0, y1 - y0);\n  }\n  ctx.restore();\n}\nfunction drawCircle(ctx, cx, cy, r, color = '#000', width = 2, filled = false) {\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = width;\n  ctx.beginPath();\n  ctx.arc(cx, cy, r, 0, 2 * Math.PI);\n  if (filled) {\n    ctx.fillStyle = color;\n    ctx.fill();\n  } else {\n    ctx.stroke();\n  }\n  ctx.restore();\n}\nfunction drawSelectionBox(ctx, bounds, selected = true) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = bounds;\n\n  // Draw selection border\n  ctx.save();\n  ctx.strokeStyle = selected ? '#0066ff' : '#cccccc';\n  ctx.lineWidth = 1;\n  ctx.setLineDash([5, 5]);\n  ctx.strokeRect(x - 2, y - 2, width + 4, height + 4);\n  ctx.restore();\n  if (selected) {\n    // Draw resize handles\n    const handleSize = 8;\n    const handles = [{\n      x: x - handleSize / 2,\n      y: y - handleSize / 2\n    },\n    // top-left\n    {\n      x: x + width / 2 - handleSize / 2,\n      y: y - handleSize / 2\n    },\n    // top-center\n    {\n      x: x + width - handleSize / 2,\n      y: y - handleSize / 2\n    },\n    // top-right\n    {\n      x: x + width - handleSize / 2,\n      y: y + height / 2 - handleSize / 2\n    },\n    // middle-right\n    {\n      x: x + width - handleSize / 2,\n      y: y + height - handleSize / 2\n    },\n    // bottom-right\n    {\n      x: x + width / 2 - handleSize / 2,\n      y: y + height - handleSize / 2\n    },\n    // bottom-center\n    {\n      x: x - handleSize / 2,\n      y: y + height - handleSize / 2\n    },\n    // bottom-left\n    {\n      x: x - handleSize / 2,\n      y: y + height / 2 - handleSize / 2\n    } // middle-left\n    ];\n    ctx.save();\n    ctx.fillStyle = '#0066ff';\n    ctx.strokeStyle = '#ffffff';\n    ctx.lineWidth = 1;\n    ctx.setLineDash([]);\n    handles.forEach(handle => {\n      ctx.fillRect(handle.x, handle.y, handleSize, handleSize);\n      ctx.strokeRect(handle.x, handle.y, handleSize, handleSize);\n    });\n    ctx.restore();\n  }\n}\nconst Canvas = /*#__PURE__*/_s(/*#__PURE__*/forwardRef(_c = _s(({\n  activeTool = 'pen',\n  diagramId,\n  initialData,\n  onCanvasChange\n}, ref) => {\n  _s();\n  const canvasRef = useRef(null);\n  const fileInputRef = useRef(null);\n  const imageCache = useRef(new Map()); // Cache loaded images\n  const [drawing, setDrawing] = useState(false);\n  const [start, setStart] = useState(null);\n  const [history, setHistory] = useState([]);\n  const [currentStroke, setCurrentStroke] = useState([]);\n  const [color, setColor] = useState('#000000');\n  const [lineWidth, setLineWidth] = useState(2);\n  const [selectedElements, setSelectedElements] = useState([]);\n  const [dragStart, setDragStart] = useState(null);\n  const [isDragging, setIsDragging] = useState(false);\n  const [resizeHandle, setResizeHandle] = useState(null);\n  const [isResizing, setIsResizing] = useState(false);\n  const [originalBounds, setOriginalBounds] = useState(null);\n  const [dragStartPositions, setDragStartPositions] = useState(null);\n  const changeTimeoutRef = useRef(null);\n\n  // Helper function to preload image into cache\n  const preloadImage = src => {\n    if (!imageCache.current.has(src)) {\n      const img = new Image();\n      img.onload = () => {\n        // Image loaded, trigger redraw to show it\n        requestAnimationFrame(() => redraw());\n      };\n      img.onerror = () => {\n        console.error('Failed to preload image:', src);\n      };\n      imageCache.current.set(src, img);\n      img.src = src;\n    }\n  };\n\n  // Generate unique ID for elements\n  const generateId = () => Date.now() + Math.random().toString(36).substr(2, 9);\n\n  // Calculate element bounds\n  const getElementBounds = element => {\n    if (!element) return null;\n    if (element.type === ELEMENT_TYPES.LINE || element.tool === TOOLS.LINE) {\n      const [p0, p1] = element.points;\n      return {\n        x: Math.min(p0.x, p1.x),\n        y: Math.min(p0.y, p1.y),\n        width: Math.abs(p1.x - p0.x),\n        height: Math.abs(p1.y - p0.y)\n      };\n    } else if (element.type === ELEMENT_TYPES.RECT || element.tool === TOOLS.RECT) {\n      const [p0, p1] = element.points;\n      return {\n        x: Math.min(p0.x, p1.x),\n        y: Math.min(p0.y, p1.y),\n        width: Math.abs(p1.x - p0.x),\n        height: Math.abs(p1.y - p0.y)\n      };\n    } else if (element.type === ELEMENT_TYPES.CIRCLE || element.tool === TOOLS.CIRCLE) {\n      return {\n        x: element.center.x - element.radius,\n        y: element.center.y - element.radius,\n        width: element.radius * 2,\n        height: element.radius * 2\n      };\n    } else if (element.type === ELEMENT_TYPES.PEN || element.tool === TOOLS.PEN) {\n      if (!element.points || element.points.length === 0) return null;\n      const xs = element.points.map(p => p.x);\n      const ys = element.points.map(p => p.y);\n      const minX = Math.min(...xs);\n      const maxX = Math.max(...xs);\n      const minY = Math.min(...ys);\n      const maxY = Math.max(...ys);\n      return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n      };\n    } else if (element.type === ELEMENT_TYPES.IMAGE) {\n      return {\n        x: element.x,\n        y: element.y,\n        width: element.width,\n        height: element.height\n      };\n    }\n    return null;\n  };\n\n  // Check if point is inside element\n  const isPointInElement = (point, element) => {\n    const bounds = getElementBounds(element);\n    if (!bounds) return false;\n    return point.x >= bounds.x && point.x <= bounds.x + bounds.width && point.y >= bounds.y && point.y <= bounds.y + bounds.height;\n  };\n\n  // Check if point is on resize handle\n  const getResizeHandle = (point, bounds) => {\n    if (!bounds) return null;\n    const handleSize = 8;\n    const {\n      x,\n      y,\n      width,\n      height\n    } = bounds;\n    const handles = [{\n      name: 'nw',\n      x: x - handleSize / 2,\n      y: y - handleSize / 2\n    }, {\n      name: 'n',\n      x: x + width / 2 - handleSize / 2,\n      y: y - handleSize / 2\n    }, {\n      name: 'ne',\n      x: x + width - handleSize / 2,\n      y: y - handleSize / 2\n    }, {\n      name: 'e',\n      x: x + width - handleSize / 2,\n      y: y + height / 2 - handleSize / 2\n    }, {\n      name: 'se',\n      x: x + width - handleSize / 2,\n      y: y + height - handleSize / 2\n    }, {\n      name: 's',\n      x: x + width / 2 - handleSize / 2,\n      y: y + height - handleSize / 2\n    }, {\n      name: 'sw',\n      x: x - handleSize / 2,\n      y: y + height - handleSize / 2\n    }, {\n      name: 'w',\n      x: x - handleSize / 2,\n      y: y + height / 2 - handleSize / 2\n    }];\n    for (const handle of handles) {\n      if (point.x >= handle.x && point.x <= handle.x + handleSize && point.y >= handle.y && point.y <= handle.y + handleSize) {\n        return handle.name;\n      }\n    }\n    return null;\n  };\n\n  // Handle image paste/upload\n  const handleImageUpload = file => {\n    if (file && file.type.startsWith('image/')) {\n      const reader = new FileReader();\n      reader.onload = e => {\n        const img = new Image();\n        img.onload = () => {\n          // Scale image to fit canvas if too large\n          let width = img.width;\n          let height = img.height;\n          const maxSize = 300;\n          if (width > maxSize || height > maxSize) {\n            const ratio = Math.min(maxSize / width, maxSize / height);\n            width *= ratio;\n            height *= ratio;\n          }\n          const element = {\n            id: generateId(),\n            type: ELEMENT_TYPES.IMAGE,\n            x: 50,\n            y: 50,\n            width,\n            height,\n            src: e.target.result\n          };\n\n          // Preload the image into cache\n          preloadImage(e.target.result);\n          setHistory(prev => [...prev, element]);\n        };\n        img.src = e.target.result;\n      };\n      reader.readAsDataURL(file);\n    }\n  };\n\n  // Handle clipboard paste\n  const handlePaste = useCallback(e => {\n    const items = e.clipboardData.items;\n    for (let i = 0; i < items.length; i++) {\n      if (items[i].type.startsWith('image/')) {\n        const file = items[i].getAsFile();\n        handleImageUpload(file);\n        e.preventDefault();\n        break;\n      }\n    }\n  }, []);\n\n  // Expose methods to parent component\n  useImperativeHandle(ref, () => ({\n    getCanvasData: () => {\n      return history;\n    },\n    clearCanvas: () => {\n      setHistory([]);\n      setSelectedElements([]);\n      if (onCanvasChange) {\n        onCanvasChange([]);\n      }\n    },\n    loadCanvasData: data => {\n      if (data && Array.isArray(data)) {\n        // Preload any images in the data\n        data.forEach(item => {\n          if (item.type === ELEMENT_TYPES.IMAGE && item.src) {\n            preloadImage(item.src);\n          }\n        });\n        setHistory(data);\n        setSelectedElements([]);\n      }\n    },\n    deleteSelected: () => {\n      if (selectedElements.length > 0) {\n        const selectedIds = selectedElements.map(el => el.id);\n        setHistory(prev => prev.filter(el => !selectedIds.includes(el.id)));\n        setSelectedElements([]);\n      }\n    }\n  }));\n\n  // Load initial data when component mounts\n  useEffect(() => {\n    if (initialData && initialData.elements) {\n      setHistory(initialData.elements);\n    }\n  }, [initialData]);\n\n  // Add paste event listener\n  useEffect(() => {\n    document.addEventListener('paste', handlePaste);\n    return () => {\n      document.removeEventListener('paste', handlePaste);\n    };\n  }, [handlePaste]);\n\n  // Call onCanvasChange when history changes (debounced)\n  useEffect(() => {\n    // Clear previous timeout\n    if (changeTimeoutRef.current) {\n      clearTimeout(changeTimeoutRef.current);\n    }\n\n    // Only trigger onCanvasChange if there are actual changes\n    if (onCanvasChange && history.length >= 0) {\n      changeTimeoutRef.current = setTimeout(() => {\n        onCanvasChange(history);\n        changeTimeoutRef.current = null;\n      }, 500); // Debounce by 500ms to avoid excessive calls\n    }\n\n    // Cleanup on unmount\n    return () => {\n      if (changeTimeoutRef.current) {\n        clearTimeout(changeTimeoutRef.current);\n      }\n    };\n  }, [history, onCanvasChange]);\n  const redraw = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n    // Draw white background\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n    // Draw all elements\n    history.forEach(item => {\n      if (item.tool === TOOLS.PEN || item.type === ELEMENT_TYPES.PEN) {\n        for (let i = 1; i < item.points.length; i++) {\n          drawLine(ctx, item.points[i - 1].x, item.points[i - 1].y, item.points[i].x, item.points[i].y, item.color, item.width);\n        }\n      } else if (item.tool === TOOLS.LINE || item.type === ELEMENT_TYPES.LINE) {\n        const [p0, p1] = item.points;\n        drawLine(ctx, p0.x, p0.y, p1.x, p1.y, item.color, item.width);\n      } else if (item.tool === TOOLS.RECT || item.type === ELEMENT_TYPES.RECT) {\n        const [p0, p1] = item.points;\n        drawRect(ctx, p0.x, p0.y, p1.x, p1.y, item.color, item.width);\n      } else if (item.tool === TOOLS.CIRCLE || item.type === ELEMENT_TYPES.CIRCLE) {\n        if (item.center && item.radius) {\n          drawCircle(ctx, item.center.x, item.center.y, item.radius, item.color, item.width);\n        }\n      } else if (item.type === ELEMENT_TYPES.IMAGE) {\n        // Check if image is already cached\n        let img = imageCache.current.get(item.src);\n        if (img && img.complete) {\n          // Image is cached and loaded, draw immediately\n          ctx.drawImage(img, item.x, item.y, item.width, item.height);\n        } else if (!img) {\n          // Image not in cache, create and cache it\n          img = new Image();\n          img.onload = () => {\n            // Mark image as loaded and trigger a single redraw\n            requestAnimationFrame(() => redraw());\n          };\n          img.onerror = () => {\n            console.error('Failed to load image:', item.src);\n          };\n          imageCache.current.set(item.src, img);\n          img.src = item.src;\n        }\n        // If img exists but not complete, it's still loading - do nothing\n      }\n    });\n\n    // Draw selection boxes\n    selectedElements.forEach(element => {\n      const bounds = getElementBounds(element);\n      if (bounds) {\n        drawSelectionBox(ctx, bounds, true);\n      }\n    });\n  }, [history, selectedElements]);\n  useEffect(() => {\n    redraw();\n  }, [redraw]);\n\n  // Cleanup image cache on unmount\n  useEffect(() => {\n    return () => {\n      imageCache.current.clear();\n    };\n  }, []);\n  const getMousePos = e => {\n    const rect = canvasRef.current.getBoundingClientRect();\n    return {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top\n    };\n  };\n  const handlePointerDown = e => {\n    const {\n      x,\n      y\n    } = getMousePos(e);\n    const point = {\n      x,\n      y\n    };\n    if (activeTool === TOOLS.SELECT) {\n      // Check if clicking on a resize handle first\n      let handleFound = false;\n      for (const element of selectedElements) {\n        const bounds = getElementBounds(element);\n        if (bounds) {\n          const handle = getResizeHandle(point, bounds);\n          if (handle) {\n            setResizeHandle(handle);\n            setIsResizing(true);\n            setStart(point);\n            setOriginalBounds(bounds); // Store original bounds for resize calculations\n            handleFound = true;\n            break;\n          }\n        }\n      }\n      if (!handleFound) {\n        // Check if clicking on an element\n        let elementFound = null;\n        for (let i = history.length - 1; i >= 0; i--) {\n          if (isPointInElement(point, history[i])) {\n            elementFound = history[i];\n            break;\n          }\n        }\n        if (elementFound) {\n          // Check if element is already selected\n          const isAlreadySelected = selectedElements.some(el => el.id === elementFound.id);\n          if (e.ctrlKey || e.metaKey) {\n            // Multi-select\n            if (isAlreadySelected) {\n              setSelectedElements(prev => prev.filter(el => el.id !== elementFound.id));\n            } else {\n              setSelectedElements(prev => [...prev, elementFound]);\n            }\n          } else {\n            if (!isAlreadySelected) {\n              setSelectedElements([elementFound]);\n            }\n            setIsDragging(true);\n            setDragStart(point);\n            // Store original positions for consistent dragging\n            setDragStartPositions(selectedElements.map(el => ({\n              id: el.id,\n              originalElement: {\n                ...el\n              }\n            })));\n          }\n        } else {\n          // Clicked on empty space\n          setSelectedElements([]);\n        }\n      }\n    } else {\n      // Drawing tools\n      setDrawing(true);\n      setStart(point);\n      if (activeTool === TOOLS.PEN) {\n        setCurrentStroke([point]);\n      }\n    }\n  };\n  const handlePointerMove = e => {\n    const {\n      x,\n      y\n    } = getMousePos(e);\n    const point = {\n      x,\n      y\n    };\n\n    // Update cursor based on what's under the mouse\n    if (activeTool === TOOLS.SELECT && !isDragging && !isResizing) {\n      let cursorStyle = 'default';\n\n      // Check for resize handles\n      for (const element of selectedElements) {\n        const bounds = getElementBounds(element);\n        if (bounds) {\n          const handle = getResizeHandle(point, bounds);\n          if (handle) {\n            const cursors = {\n              'nw': 'nw-resize',\n              'n': 'n-resize',\n              'ne': 'ne-resize',\n              'w': 'w-resize',\n              'e': 'e-resize',\n              'sw': 'sw-resize',\n              's': 's-resize',\n              'se': 'se-resize'\n            };\n            cursorStyle = cursors[handle];\n            break;\n          }\n        }\n      }\n\n      // Check for elements under cursor\n      if (cursorStyle === 'default') {\n        for (let i = history.length - 1; i >= 0; i--) {\n          if (isPointInElement(point, history[i])) {\n            cursorStyle = 'pointer';\n            break;\n          }\n        }\n      }\n      canvasRef.current.style.cursor = cursorStyle;\n    } else if (activeTool !== TOOLS.SELECT) {\n      canvasRef.current.style.cursor = 'crosshair';\n    }\n\n    // Handle different interaction modes\n    if (isResizing && selectedElements.length > 0 && originalBounds) {\n      // Resize selected elements\n      const dx = x - start.x;\n      const dy = y - start.y;\n      const updatedHistory = history.map(element => {\n        const selected = selectedElements.find(sel => sel.id === element.id);\n        if (!selected) return element;\n\n        // Use the stored original bounds for consistent resize calculations\n        return resizeElement(element, resizeHandle, dx, dy, originalBounds);\n      });\n      setHistory(updatedHistory);\n\n      // Update selectedElements to match the resized elements\n      const updatedSelected = selectedElements.map(selected => {\n        const updated = updatedHistory.find(el => el.id === selected.id);\n        return updated || selected;\n      });\n      setSelectedElements(updatedSelected);\n    } else if (isDragging && selectedElements.length > 0 && dragStartPositions) {\n      // Drag selected elements using original positions as reference\n      const dx = x - dragStart.x;\n      const dy = y - dragStart.y;\n      const updatedHistory = history.map(element => {\n        const dragStartPos = dragStartPositions.find(pos => pos.id === element.id);\n        if (!dragStartPos) return element;\n        const originalElement = dragStartPos.originalElement;\n\n        // Apply drag offset to original positions\n        if (originalElement.type === ELEMENT_TYPES.IMAGE) {\n          return {\n            ...element,\n            x: originalElement.x + dx,\n            y: originalElement.y + dy\n          };\n        }\n        if (originalElement.points) {\n          return {\n            ...element,\n            points: originalElement.points.map(p => ({\n              x: p.x + dx,\n              y: p.y + dy\n            }))\n          };\n        }\n        if (originalElement.center) {\n          return {\n            ...element,\n            center: {\n              x: originalElement.center.x + dx,\n              y: originalElement.center.y + dy\n            }\n          };\n        }\n        return element;\n      });\n      setHistory(updatedHistory);\n\n      // Update selectedElements to match the moved elements\n      const updatedSelected = selectedElements.map(selected => {\n        const updated = updatedHistory.find(el => el.id === selected.id);\n        return updated || selected;\n      });\n      setSelectedElements(updatedSelected);\n    } else if (drawing && activeTool !== TOOLS.SELECT) {\n      // Drawing mode\n      if (activeTool === TOOLS.PEN) {\n        setCurrentStroke(prev => [...prev, point]);\n        const ctx = canvasRef.current.getContext('2d');\n        if (currentStroke.length > 0) {\n          const lastPoint = currentStroke[currentStroke.length - 1];\n          drawLine(ctx, lastPoint.x, lastPoint.y, x, y, color, lineWidth);\n        }\n      } else {\n        // Preview shape\n        redraw();\n        const ctx = canvasRef.current.getContext('2d');\n        if (activeTool === TOOLS.LINE && start) {\n          drawLine(ctx, start.x, start.y, x, y, color, lineWidth);\n        } else if (activeTool === TOOLS.RECT && start) {\n          drawRect(ctx, start.x, start.y, x, y, color, lineWidth);\n        } else if (activeTool === TOOLS.CIRCLE && start) {\n          const radius = Math.hypot(x - start.x, y - start.y);\n          drawCircle(ctx, start.x, start.y, radius, color, lineWidth);\n        }\n      }\n    }\n  };\n\n  // Helper function to resize an element\n  const resizeElement = (element, handle, dx, dy, originalBounds) => {\n    if (element.type === ELEMENT_TYPES.IMAGE) {\n      const newElement = {\n        ...element\n      };\n      switch (handle) {\n        case 'se':\n          // bottom-right\n          newElement.width = Math.max(20, originalBounds.width + dx);\n          newElement.height = Math.max(20, originalBounds.height + dy);\n          break;\n        case 'sw':\n          // bottom-left\n          newElement.x = originalBounds.x + dx;\n          newElement.width = Math.max(20, originalBounds.width - dx);\n          newElement.height = Math.max(20, originalBounds.height + dy);\n          break;\n        case 'ne':\n          // top-right\n          newElement.width = Math.max(20, originalBounds.width + dx);\n          newElement.y = originalBounds.y + dy;\n          newElement.height = Math.max(20, originalBounds.height - dy);\n          break;\n        case 'nw':\n          // top-left\n          newElement.x = originalBounds.x + dx;\n          newElement.y = originalBounds.y + dy;\n          newElement.width = Math.max(20, originalBounds.width - dx);\n          newElement.height = Math.max(20, originalBounds.height - dy);\n          break;\n        case 'n':\n          // top-center\n          newElement.y = originalBounds.y + dy;\n          newElement.height = Math.max(20, originalBounds.height - dy);\n          break;\n        case 's':\n          // bottom-center\n          newElement.height = Math.max(20, originalBounds.height + dy);\n          break;\n        case 'e':\n          // middle-right\n          newElement.width = Math.max(20, originalBounds.width + dx);\n          break;\n        case 'w':\n          // middle-left\n          newElement.x = originalBounds.x + dx;\n          newElement.width = Math.max(20, originalBounds.width - dx);\n          break;\n      }\n      return newElement;\n    }\n\n    // For rectangles, simplify the logic\n    if (element.tool === TOOLS.RECT || element.type === ELEMENT_TYPES.RECT) {\n      const newElement = {\n        ...element\n      };\n\n      // Calculate new bounds\n      let newX = originalBounds.x;\n      let newY = originalBounds.y;\n      let newWidth = originalBounds.width;\n      let newHeight = originalBounds.height;\n      switch (handle) {\n        case 'nw':\n          // top-left\n          newX = originalBounds.x + dx;\n          newY = originalBounds.y + dy;\n          newWidth = Math.max(20, originalBounds.width - dx);\n          newHeight = Math.max(20, originalBounds.height - dy);\n          break;\n        case 'n':\n          // top-center\n          newY = originalBounds.y + dy;\n          newHeight = Math.max(20, originalBounds.height - dy);\n          break;\n        case 'ne':\n          // top-right\n          newY = originalBounds.y + dy;\n          newWidth = Math.max(20, originalBounds.width + dx);\n          newHeight = Math.max(20, originalBounds.height - dy);\n          break;\n        case 'e':\n          // middle-right\n          newWidth = Math.max(20, originalBounds.width + dx);\n          break;\n        case 'se':\n          // bottom-right\n          newWidth = Math.max(20, originalBounds.width + dx);\n          newHeight = Math.max(20, originalBounds.height + dy);\n          break;\n        case 's':\n          // bottom-center\n          newHeight = Math.max(20, originalBounds.height + dy);\n          break;\n        case 'sw':\n          // bottom-left\n          newX = originalBounds.x + dx;\n          newWidth = Math.max(20, originalBounds.width - dx);\n          newHeight = Math.max(20, originalBounds.height + dy);\n          break;\n        case 'w':\n          // middle-left\n          newX = originalBounds.x + dx;\n          newWidth = Math.max(20, originalBounds.width - dx);\n          break;\n      }\n\n      // Convert back to points\n      newElement.points = [{\n        x: newX,\n        y: newY\n      }, {\n        x: newX + newWidth,\n        y: newY + newHeight\n      }];\n      return newElement;\n    }\n\n    // Handle lines\n    if (element.tool === TOOLS.LINE || element.type === ELEMENT_TYPES.LINE) {\n      const newElement = {\n        ...element\n      };\n      const [p0, p1] = element.points;\n\n      // Calculate new bounds\n      let newX = originalBounds.x;\n      let newY = originalBounds.y;\n      let newWidth = originalBounds.width;\n      let newHeight = originalBounds.height;\n      switch (handle) {\n        case 'nw':\n          // top-left\n          newX = originalBounds.x + dx;\n          newY = originalBounds.y + dy;\n          newWidth = Math.max(1, originalBounds.width - dx);\n          newHeight = Math.max(1, originalBounds.height - dy);\n          break;\n        case 'n':\n          // top-center\n          newY = originalBounds.y + dy;\n          newHeight = Math.max(1, originalBounds.height - dy);\n          break;\n        case 'ne':\n          // top-right\n          newY = originalBounds.y + dy;\n          newWidth = Math.max(1, originalBounds.width + dx);\n          newHeight = Math.max(1, originalBounds.height - dy);\n          break;\n        case 'e':\n          // middle-right\n          newWidth = Math.max(1, originalBounds.width + dx);\n          break;\n        case 'se':\n          // bottom-right\n          newWidth = Math.max(1, originalBounds.width + dx);\n          newHeight = Math.max(1, originalBounds.height + dy);\n          break;\n        case 's':\n          // bottom-center\n          newHeight = Math.max(1, originalBounds.height + dy);\n          break;\n        case 'sw':\n          // bottom-left\n          newX = originalBounds.x + dx;\n          newWidth = Math.max(1, originalBounds.width - dx);\n          newHeight = Math.max(1, originalBounds.height + dy);\n          break;\n        case 'w':\n          // middle-left\n          newX = originalBounds.x + dx;\n          newWidth = Math.max(1, originalBounds.width - dx);\n          break;\n      }\n\n      // Convert back to points\n      newElement.points = [{\n        x: newX,\n        y: newY\n      }, {\n        x: newX + newWidth,\n        y: newY + newHeight\n      }];\n      return newElement;\n    }\n\n    // Handle freehand drawings (pen)\n    if (element.tool === TOOLS.PEN || element.type === ELEMENT_TYPES.PEN) {\n      const newElement = {\n        ...element\n      };\n      if (!element.points || element.points.length === 0) {\n        return element;\n      }\n\n      // Apply dampening factor to make resizing less sensitive\n      const dampening = 0.1; // 90% reduction - very fine control\n      const dampedDx = dx * dampening;\n      const dampedDy = dy * dampening;\n\n      // Calculate new bounds based on handle with dampened movement\n      let newX = originalBounds.x;\n      let newY = originalBounds.y;\n      let newWidth = originalBounds.width;\n      let newHeight = originalBounds.height;\n      switch (handle) {\n        case 'nw':\n          // top-left\n          newX = originalBounds.x + dampedDx;\n          newY = originalBounds.y + dampedDy;\n          newWidth = Math.max(10, originalBounds.width - dampedDx);\n          newHeight = Math.max(10, originalBounds.height - dampedDy);\n          break;\n        case 'n':\n          // top-center\n          newY = originalBounds.y + dampedDy;\n          newHeight = Math.max(10, originalBounds.height - dampedDy);\n          break;\n        case 'ne':\n          // top-right\n          newY = originalBounds.y + dampedDy;\n          newWidth = Math.max(10, originalBounds.width + dampedDx);\n          newHeight = Math.max(10, originalBounds.height - dampedDy);\n          break;\n        case 'e':\n          // middle-right\n          newWidth = Math.max(10, originalBounds.width + dampedDx);\n          break;\n        case 'se':\n          // bottom-right\n          newWidth = Math.max(10, originalBounds.width + dampedDx);\n          newHeight = Math.max(10, originalBounds.height + dampedDy);\n          break;\n        case 's':\n          // bottom-center\n          newHeight = Math.max(10, originalBounds.height + dampedDy);\n          break;\n        case 'sw':\n          // bottom-left\n          newX = originalBounds.x + dampedDx;\n          newWidth = Math.max(10, originalBounds.width - dampedDx);\n          newHeight = Math.max(10, originalBounds.height + dampedDy);\n          break;\n        case 'w':\n          // middle-left\n          newX = originalBounds.x + dampedDx;\n          newWidth = Math.max(10, originalBounds.width - dampedDx);\n          break;\n      }\n\n      // Calculate scaling factors (now based on dampened movement)\n      const scaleX = originalBounds.width > 0 ? newWidth / originalBounds.width : 1;\n      const scaleY = originalBounds.height > 0 ? newHeight / originalBounds.height : 1;\n\n      // Transform all points\n      newElement.points = element.points.map(point => {\n        const relativeX = point.x - originalBounds.x;\n        const relativeY = point.y - originalBounds.y;\n        return {\n          x: newX + relativeX * scaleX,\n          y: newY + relativeY * scaleY\n        };\n      });\n      return newElement;\n    }\n\n    // Handle circles\n    if (element.tool === TOOLS.CIRCLE || element.type === ELEMENT_TYPES.CIRCLE) {\n      const newElement = {\n        ...element\n      };\n      switch (handle) {\n        case 'se':\n        case 'ne':\n        case 'sw':\n        case 'nw':\n          // For corners, adjust radius based on distance from center\n          const newRadius = Math.max(10, originalBounds.width / 2 + (handle.includes('e') ? dx : -dx));\n          newElement.radius = newRadius;\n          break;\n        case 'n':\n        case 's':\n          const newRadiusY = Math.max(10, originalBounds.height / 2 + (handle === 's' ? dy : -dy));\n          newElement.radius = newRadiusY;\n          break;\n        case 'e':\n        case 'w':\n          const newRadiusX = Math.max(10, originalBounds.width / 2 + (handle === 'e' ? dx : -dx));\n          newElement.radius = newRadiusX;\n          break;\n      }\n      return newElement;\n    }\n    return element;\n  };\n\n  // Helper function to move an element\n  const moveElement = (element, dx, dy) => {\n    if (element.type === ELEMENT_TYPES.IMAGE) {\n      return {\n        ...element,\n        x: element.x + dx,\n        y: element.y + dy\n      };\n    }\n    if (element.points) {\n      return {\n        ...element,\n        points: element.points.map(p => ({\n          x: p.x + dx,\n          y: p.y + dy\n        }))\n      };\n    }\n    if (element.center) {\n      return {\n        ...element,\n        center: {\n          x: element.center.x + dx,\n          y: element.center.y + dy\n        }\n      };\n    }\n    return element;\n  };\n  const handlePointerUp = e => {\n    const {\n      x,\n      y\n    } = getMousePos(e);\n    if (isResizing) {\n      setIsResizing(false);\n      setResizeHandle(null);\n      setOriginalBounds(null); // Reset original bounds\n    } else if (isDragging) {\n      setIsDragging(false);\n      setDragStart(null);\n      setDragStartPositions(null);\n    } else if (drawing && activeTool !== TOOLS.SELECT) {\n      setDrawing(false);\n      let element = null;\n      if (activeTool === TOOLS.PEN) {\n        element = {\n          id: generateId(),\n          tool: TOOLS.PEN,\n          type: ELEMENT_TYPES.PEN,\n          points: [...currentStroke, {\n            x,\n            y\n          }],\n          color,\n          width: lineWidth\n        };\n        setCurrentStroke([]);\n      } else if (activeTool === TOOLS.LINE) {\n        element = {\n          id: generateId(),\n          tool: TOOLS.LINE,\n          type: ELEMENT_TYPES.LINE,\n          points: [start, {\n            x,\n            y\n          }],\n          color,\n          width: lineWidth\n        };\n      } else if (activeTool === TOOLS.RECT) {\n        element = {\n          id: generateId(),\n          tool: TOOLS.RECT,\n          type: ELEMENT_TYPES.RECT,\n          points: [start, {\n            x,\n            y\n          }],\n          color,\n          width: lineWidth\n        };\n      } else if (activeTool === TOOLS.CIRCLE) {\n        const radius = Math.hypot(x - start.x, y - start.y);\n        element = {\n          id: generateId(),\n          tool: TOOLS.CIRCLE,\n          type: ELEMENT_TYPES.CIRCLE,\n          center: start,\n          radius,\n          color,\n          width: lineWidth\n        };\n      }\n      if (element) {\n        setHistory(prev => [...prev, element]);\n        setSelectedElements([element]); // Auto-select newly created element\n      }\n    }\n    setStart(null);\n  };\n  const handleUndo = () => {\n    setHistory(prev => prev.slice(0, -1));\n    setSelectedElements([]);\n  };\n  const handleClear = () => {\n    setHistory([]);\n    setSelectedElements([]);\n  };\n  const handleDelete = () => {\n    if (selectedElements.length > 0) {\n      const selectedIds = selectedElements.map(el => el.id);\n      setHistory(prev => prev.filter(el => !selectedIds.includes(el.id)));\n      setSelectedElements([]);\n    }\n  };\n\n  // Handle keyboard events\n  const handleKeyDown = useCallback(e => {\n    if (e.key === 'Delete' || e.key === 'Backspace') {\n      handleDelete();\n      e.preventDefault();\n    } else if (e.key === 'Escape') {\n      setSelectedElements([]);\n    } else if (e.ctrlKey || e.metaKey) {\n      if (e.key === 'a') {\n        setSelectedElements([...history]);\n        e.preventDefault();\n      } else if (e.key === 'z') {\n        handleUndo();\n        e.preventDefault();\n      }\n    }\n  }, [history, selectedElements]);\n\n  // Add keyboard event listeners\n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyDown);\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [handleKeyDown]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"w-full h-full bg-gray-100 rounded-lg p-4\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mb-4 flex gap-4 items-center flex-wrap\",\n      children: [/*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"color\",\n        value: color,\n        onChange: e => setColor(e.target.value),\n        className: \"w-10 h-10 border-none rounded cursor-pointer\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1051,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"range\",\n        min: \"1\",\n        max: \"20\",\n        value: lineWidth,\n        onChange: e => setLineWidth(Number(e.target.value)),\n        className: \"w-20\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1057,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => fileInputRef.current.click(),\n        className: \"px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600\",\n        children: \"Upload Image\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1066,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        ref: fileInputRef,\n        type: \"file\",\n        accept: \"image/*\",\n        onChange: e => handleImageUpload(e.target.files[0]),\n        className: \"hidden\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1073,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleUndo,\n        disabled: history.length === 0,\n        className: \"px-3 py-1 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-50\",\n        children: \"Undo\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1081,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleClear,\n        className: \"px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600\",\n        children: \"Clear\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1088,\n        columnNumber: 9\n      }, this), selectedElements.length > 0 && /*#__PURE__*/_jsxDEV(_Fragment, {\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: handleDelete,\n          className: \"px-3 py-1 bg-red-600 text-white rounded hover:bg-red-700\",\n          children: [\"Delete (\", selectedElements.length, \")\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1097,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"text-sm text-gray-600\",\n          children: [selectedElements.length, \" selected\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1103,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1050,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mb-2 text-sm text-gray-600\",\n      children: activeTool === TOOLS.SELECT ? /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"Selection Mode - Click to select, drag to move, use handles to resize. Ctrl+Click for multi-select. Paste images with Ctrl+V\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1112,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(\"span\", {\n        children: [\"Drawing Mode - \", activeTool]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1114,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1110,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      width: CANVAS_WIDTH,\n      height: CANVAS_HEIGHT,\n      className: \"border border-gray-300 bg-white\",\n      onPointerDown: handlePointerDown,\n      onPointerMove: handlePointerMove,\n      onPointerUp: handlePointerUp,\n      onPointerLeave: handlePointerUp,\n      style: {\n        cursor: activeTool === TOOLS.SELECT ? 'default' : 'crosshair'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1118,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1049,\n    columnNumber: 5\n  }, this);\n}, \"+qHzhn6yahuDpB0DVm/gyCavm1A=\")), \"+qHzhn6yahuDpB0DVm/gyCavm1A=\");\n_c2 = Canvas;\nCanvas.displayName = 'Canvas';\nexport default Canvas;\nvar _c, _c2;\n$RefreshReg$(_c, \"Canvas$forwardRef\");\n$RefreshReg$(_c2, \"Canvas\");","map":{"version":3,"names":["React","useRef","useState","useEffect","useCallback","forwardRef","useImperativeHandle","api","jsxDEV","_jsxDEV","Fragment","_Fragment","CANVAS_WIDTH","CANVAS_HEIGHT","TOOLS","PEN","LINE","RECT","CIRCLE","TEXT","SELECT","ELEMENT_TYPES","IMAGE","drawLine","ctx","x0","y0","x1","y1","color","width","save","strokeStyle","lineWidth","lineCap","beginPath","moveTo","lineTo","stroke","restore","drawRect","filled","fillStyle","fillRect","strokeRect","drawCircle","cx","cy","r","arc","Math","PI","fill","drawSelectionBox","bounds","selected","x","y","height","setLineDash","handleSize","handles","forEach","handle","Canvas","_s","_c","activeTool","diagramId","initialData","onCanvasChange","ref","canvasRef","fileInputRef","imageCache","Map","drawing","setDrawing","start","setStart","history","setHistory","currentStroke","setCurrentStroke","setColor","setLineWidth","selectedElements","setSelectedElements","dragStart","setDragStart","isDragging","setIsDragging","resizeHandle","setResizeHandle","isResizing","setIsResizing","originalBounds","setOriginalBounds","dragStartPositions","setDragStartPositions","changeTimeoutRef","preloadImage","src","current","has","img","Image","onload","requestAnimationFrame","redraw","onerror","console","error","set","generateId","Date","now","random","toString","substr","getElementBounds","element","type","tool","p0","p1","points","min","abs","center","radius","length","xs","map","p","ys","minX","maxX","max","minY","maxY","isPointInElement","point","getResizeHandle","name","handleImageUpload","file","startsWith","reader","FileReader","e","maxSize","ratio","id","target","result","prev","readAsDataURL","handlePaste","items","clipboardData","i","getAsFile","preventDefault","getCanvasData","clearCanvas","loadCanvasData","data","Array","isArray","item","deleteSelected","selectedIds","el","filter","includes","elements","document","addEventListener","removeEventListener","clearTimeout","setTimeout","canvas","getContext","clearRect","get","complete","drawImage","clear","getMousePos","rect","getBoundingClientRect","clientX","left","clientY","top","handlePointerDown","handleFound","elementFound","isAlreadySelected","some","ctrlKey","metaKey","originalElement","handlePointerMove","cursorStyle","cursors","style","cursor","dx","dy","updatedHistory","find","sel","resizeElement","updatedSelected","updated","dragStartPos","pos","lastPoint","hypot","newElement","newX","newY","newWidth","newHeight","dampening","dampedDx","dampedDy","scaleX","scaleY","relativeX","relativeY","newRadius","newRadiusY","newRadiusX","moveElement","handlePointerUp","handleUndo","slice","handleClear","handleDelete","handleKeyDown","key","className","children","value","onChange","fileName","_jsxFileName","lineNumber","columnNumber","Number","onClick","click","accept","files","disabled","onPointerDown","onPointerMove","onPointerUp","onPointerLeave","_c2","displayName","$RefreshReg$"],"sources":["D:/Downloads/DRAW/frontend/src/components/Canvas.jsx"],"sourcesContent":["import React, { useRef, useState, useEffect, useCallback, forwardRef, useImperativeHandle } from 'react';\r\nimport api from '../api';\r\n\r\nconst CANVAS_WIDTH = 800;\r\nconst CANVAS_HEIGHT = 600;\r\n\r\nconst TOOLS = {\r\n  PEN: 'pen',\r\n  LINE: 'line',\r\n  RECT: 'rect',\r\n  CIRCLE: 'circle',\r\n  TEXT: 'text',\r\n  SELECT: 'select'\r\n};\r\n\r\nconst ELEMENT_TYPES = {\r\n  PEN: 'pen',\r\n  LINE: 'line',\r\n  RECT: 'rect',\r\n  CIRCLE: 'circle',\r\n  TEXT: 'text',\r\n  IMAGE: 'image'\r\n};\r\n\r\nfunction drawLine(ctx, x0, y0, x1, y1, color = '#000', width = 2) {\r\n  ctx.save();\r\n  ctx.strokeStyle = color;\r\n  ctx.lineWidth = width;\r\n  ctx.lineCap = 'round';\r\n  ctx.beginPath();\r\n  ctx.moveTo(x0, y0);\r\n  ctx.lineTo(x1, y1);\r\n  ctx.stroke();\r\n  ctx.restore();\r\n}\r\n\r\nfunction drawRect(ctx, x0, y0, x1, y1, color = '#000', width = 2, filled = false) {\r\n  ctx.save();\r\n  ctx.strokeStyle = color;\r\n  ctx.lineWidth = width;\r\n  if (filled) {\r\n    ctx.fillStyle = color;\r\n    ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\r\n  } else {\r\n    ctx.strokeRect(x0, y0, x1 - x0, y1 - y0);\r\n  }\r\n  ctx.restore();\r\n}\r\n\r\nfunction drawCircle(ctx, cx, cy, r, color = '#000', width = 2, filled = false) {\r\n  ctx.save();\r\n  ctx.strokeStyle = color;\r\n  ctx.lineWidth = width;\r\n  ctx.beginPath();\r\n  ctx.arc(cx, cy, r, 0, 2 * Math.PI);\r\n  if (filled) {\r\n    ctx.fillStyle = color;\r\n    ctx.fill();\r\n  } else {\r\n    ctx.stroke();\r\n  }\r\n  ctx.restore();\r\n}\r\n\r\nfunction drawSelectionBox(ctx, bounds, selected = true) {\r\n  const { x, y, width, height } = bounds;\r\n  \r\n  // Draw selection border\r\n  ctx.save();\r\n  ctx.strokeStyle = selected ? '#0066ff' : '#cccccc';\r\n  ctx.lineWidth = 1;\r\n  ctx.setLineDash([5, 5]);\r\n  ctx.strokeRect(x - 2, y - 2, width + 4, height + 4);\r\n  ctx.restore();\r\n  \r\n  if (selected) {\r\n    // Draw resize handles\r\n    const handleSize = 8;\r\n    const handles = [\r\n      { x: x - handleSize/2, y: y - handleSize/2 }, // top-left\r\n      { x: x + width/2 - handleSize/2, y: y - handleSize/2 }, // top-center\r\n      { x: x + width - handleSize/2, y: y - handleSize/2 }, // top-right\r\n      { x: x + width - handleSize/2, y: y + height/2 - handleSize/2 }, // middle-right\r\n      { x: x + width - handleSize/2, y: y + height - handleSize/2 }, // bottom-right\r\n      { x: x + width/2 - handleSize/2, y: y + height - handleSize/2 }, // bottom-center\r\n      { x: x - handleSize/2, y: y + height - handleSize/2 }, // bottom-left\r\n      { x: x - handleSize/2, y: y + height/2 - handleSize/2 }, // middle-left\r\n    ];\r\n    \r\n    ctx.save();\r\n    ctx.fillStyle = '#0066ff';\r\n    ctx.strokeStyle = '#ffffff';\r\n    ctx.lineWidth = 1;\r\n    ctx.setLineDash([]);\r\n    \r\n    handles.forEach(handle => {\r\n      ctx.fillRect(handle.x, handle.y, handleSize, handleSize);\r\n      ctx.strokeRect(handle.x, handle.y, handleSize, handleSize);\r\n    });\r\n    ctx.restore();\r\n  }\r\n}\r\n\r\nconst Canvas = forwardRef(({ activeTool = 'pen', diagramId, initialData, onCanvasChange }, ref) => {\r\n  const canvasRef = useRef(null);\r\n  const fileInputRef = useRef(null);\r\n  const imageCache = useRef(new Map()); // Cache loaded images\r\n  const [drawing, setDrawing] = useState(false);\r\n  const [start, setStart] = useState(null);\r\n  const [history, setHistory] = useState([]);\r\n  const [currentStroke, setCurrentStroke] = useState([]);\r\n  const [color, setColor] = useState('#000000');\r\n  const [lineWidth, setLineWidth] = useState(2);\r\n  const [selectedElements, setSelectedElements] = useState([]);\r\n  const [dragStart, setDragStart] = useState(null);\r\n  const [isDragging, setIsDragging] = useState(false);\r\n  const [resizeHandle, setResizeHandle] = useState(null);\r\n  const [isResizing, setIsResizing] = useState(false);\r\n  const [originalBounds, setOriginalBounds] = useState(null);\r\n  const [dragStartPositions, setDragStartPositions] = useState(null);\r\n  const changeTimeoutRef = useRef(null);\r\n\r\n  // Helper function to preload image into cache\r\n  const preloadImage = (src) => {\r\n    if (!imageCache.current.has(src)) {\r\n      const img = new Image();\r\n      img.onload = () => {\r\n        // Image loaded, trigger redraw to show it\r\n        requestAnimationFrame(() => redraw());\r\n      };\r\n      img.onerror = () => {\r\n        console.error('Failed to preload image:', src);\r\n      };\r\n      imageCache.current.set(src, img);\r\n      img.src = src;\r\n    }\r\n  };\r\n\r\n  // Generate unique ID for elements\r\n  const generateId = () => Date.now() + Math.random().toString(36).substr(2, 9);\r\n\r\n  // Calculate element bounds\r\n  const getElementBounds = (element) => {\r\n    if (!element) return null;\r\n    \r\n    if (element.type === ELEMENT_TYPES.LINE || element.tool === TOOLS.LINE) {\r\n      const [p0, p1] = element.points;\r\n      return {\r\n        x: Math.min(p0.x, p1.x),\r\n        y: Math.min(p0.y, p1.y),\r\n        width: Math.abs(p1.x - p0.x),\r\n        height: Math.abs(p1.y - p0.y)\r\n      };\r\n    } else if (element.type === ELEMENT_TYPES.RECT || element.tool === TOOLS.RECT) {\r\n      const [p0, p1] = element.points;\r\n      return {\r\n        x: Math.min(p0.x, p1.x),\r\n        y: Math.min(p0.y, p1.y),\r\n        width: Math.abs(p1.x - p0.x),\r\n        height: Math.abs(p1.y - p0.y)\r\n      };\r\n    } else if (element.type === ELEMENT_TYPES.CIRCLE || element.tool === TOOLS.CIRCLE) {\r\n      return {\r\n        x: element.center.x - element.radius,\r\n        y: element.center.y - element.radius,\r\n        width: element.radius * 2,\r\n        height: element.radius * 2\r\n      };\r\n    } else if (element.type === ELEMENT_TYPES.PEN || element.tool === TOOLS.PEN) {\r\n      if (!element.points || element.points.length === 0) return null;\r\n      const xs = element.points.map(p => p.x);\r\n      const ys = element.points.map(p => p.y);\r\n      const minX = Math.min(...xs);\r\n      const maxX = Math.max(...xs);\r\n      const minY = Math.min(...ys);\r\n      const maxY = Math.max(...ys);\r\n      return {\r\n        x: minX,\r\n        y: minY,\r\n        width: maxX - minX,\r\n        height: maxY - minY\r\n      };\r\n    } else if (element.type === ELEMENT_TYPES.IMAGE) {\r\n      return {\r\n        x: element.x,\r\n        y: element.y,\r\n        width: element.width,\r\n        height: element.height\r\n      };\r\n    }\r\n    return null;\r\n  };\r\n\r\n  // Check if point is inside element\r\n  const isPointInElement = (point, element) => {\r\n    const bounds = getElementBounds(element);\r\n    if (!bounds) return false;\r\n    \r\n    return point.x >= bounds.x && \r\n           point.x <= bounds.x + bounds.width &&\r\n           point.y >= bounds.y && \r\n           point.y <= bounds.y + bounds.height;\r\n  };\r\n\r\n  // Check if point is on resize handle\r\n  const getResizeHandle = (point, bounds) => {\r\n    if (!bounds) return null;\r\n    \r\n    const handleSize = 8;\r\n    const { x, y, width, height } = bounds;\r\n    \r\n    const handles = [\r\n      { name: 'nw', x: x - handleSize/2, y: y - handleSize/2 },\r\n      { name: 'n', x: x + width/2 - handleSize/2, y: y - handleSize/2 },\r\n      { name: 'ne', x: x + width - handleSize/2, y: y - handleSize/2 },\r\n      { name: 'e', x: x + width - handleSize/2, y: y + height/2 - handleSize/2 },\r\n      { name: 'se', x: x + width - handleSize/2, y: y + height - handleSize/2 },\r\n      { name: 's', x: x + width/2 - handleSize/2, y: y + height - handleSize/2 },\r\n      { name: 'sw', x: x - handleSize/2, y: y + height - handleSize/2 },\r\n      { name: 'w', x: x - handleSize/2, y: y + height/2 - handleSize/2 },\r\n    ];\r\n    \r\n    for (const handle of handles) {\r\n      if (point.x >= handle.x && point.x <= handle.x + handleSize &&\r\n          point.y >= handle.y && point.y <= handle.y + handleSize) {\r\n        return handle.name;\r\n      }\r\n    }\r\n    return null;\r\n  };\r\n\r\n  // Handle image paste/upload\r\n  const handleImageUpload = (file) => {\r\n    if (file && file.type.startsWith('image/')) {\r\n      const reader = new FileReader();\r\n      reader.onload = (e) => {\r\n        const img = new Image();\r\n        img.onload = () => {\r\n          // Scale image to fit canvas if too large\r\n          let width = img.width;\r\n          let height = img.height;\r\n          const maxSize = 300;\r\n          \r\n          if (width > maxSize || height > maxSize) {\r\n            const ratio = Math.min(maxSize / width, maxSize / height);\r\n            width *= ratio;\r\n            height *= ratio;\r\n          }\r\n          \r\n          const element = {\r\n            id: generateId(),\r\n            type: ELEMENT_TYPES.IMAGE,\r\n            x: 50,\r\n            y: 50,\r\n            width,\r\n            height,\r\n            src: e.target.result\r\n          };\r\n          \r\n          // Preload the image into cache\r\n          preloadImage(e.target.result);\r\n          \r\n          setHistory(prev => [...prev, element]);\r\n        };\r\n        img.src = e.target.result;\r\n      };\r\n      reader.readAsDataURL(file);\r\n    }\r\n  };\r\n\r\n  // Handle clipboard paste\r\n  const handlePaste = useCallback((e) => {\r\n    const items = e.clipboardData.items;\r\n    for (let i = 0; i < items.length; i++) {\r\n      if (items[i].type.startsWith('image/')) {\r\n        const file = items[i].getAsFile();\r\n        handleImageUpload(file);\r\n        e.preventDefault();\r\n        break;\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  // Expose methods to parent component\r\n  useImperativeHandle(ref, () => ({\r\n    getCanvasData: () => {\r\n      return history;\r\n    },\r\n    clearCanvas: () => {\r\n      setHistory([]);\r\n      setSelectedElements([]);\r\n      if (onCanvasChange) {\r\n        onCanvasChange([]);\r\n      }\r\n    },\r\n    loadCanvasData: (data) => {\r\n      if (data && Array.isArray(data)) {\r\n        // Preload any images in the data\r\n        data.forEach(item => {\r\n          if (item.type === ELEMENT_TYPES.IMAGE && item.src) {\r\n            preloadImage(item.src);\r\n          }\r\n        });\r\n        \r\n        setHistory(data);\r\n        setSelectedElements([]);\r\n      }\r\n    },\r\n    deleteSelected: () => {\r\n      if (selectedElements.length > 0) {\r\n        const selectedIds = selectedElements.map(el => el.id);\r\n        setHistory(prev => prev.filter(el => !selectedIds.includes(el.id)));\r\n        setSelectedElements([]);\r\n      }\r\n    }\r\n  }));\r\n\r\n  // Load initial data when component mounts\r\n  useEffect(() => {\r\n    if (initialData && initialData.elements) {\r\n      setHistory(initialData.elements);\r\n    }\r\n  }, [initialData]);\r\n\r\n  // Add paste event listener\r\n  useEffect(() => {\r\n    document.addEventListener('paste', handlePaste);\r\n    return () => {\r\n      document.removeEventListener('paste', handlePaste);\r\n    };\r\n  }, [handlePaste]);\r\n\r\n  // Call onCanvasChange when history changes (debounced)\r\n  useEffect(() => {\r\n    // Clear previous timeout\r\n    if (changeTimeoutRef.current) {\r\n      clearTimeout(changeTimeoutRef.current);\r\n    }\r\n    \r\n    // Only trigger onCanvasChange if there are actual changes\r\n    if (onCanvasChange && history.length >= 0) {\r\n      changeTimeoutRef.current = setTimeout(() => {\r\n        onCanvasChange(history);\r\n        changeTimeoutRef.current = null;\r\n      }, 500); // Debounce by 500ms to avoid excessive calls\r\n    }\r\n\r\n    // Cleanup on unmount\r\n    return () => {\r\n      if (changeTimeoutRef.current) {\r\n        clearTimeout(changeTimeoutRef.current);\r\n      }\r\n    };\r\n  }, [history, onCanvasChange]);\r\n\r\n  const redraw = useCallback(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n    \r\n    const ctx = canvas.getContext('2d');\r\n    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n    \r\n    // Draw white background\r\n    ctx.fillStyle = 'white';\r\n    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n    \r\n    // Draw all elements\r\n    history.forEach((item) => {\r\n      if (item.tool === TOOLS.PEN || item.type === ELEMENT_TYPES.PEN) {\r\n        for (let i = 1; i < item.points.length; i++) {\r\n          drawLine(ctx, \r\n            item.points[i-1].x, item.points[i-1].y,\r\n            item.points[i].x, item.points[i].y,\r\n            item.color, item.width\r\n          );\r\n        }\r\n      } else if (item.tool === TOOLS.LINE || item.type === ELEMENT_TYPES.LINE) {\r\n        const [p0, p1] = item.points;\r\n        drawLine(ctx, p0.x, p0.y, p1.x, p1.y, item.color, item.width);\r\n      } else if (item.tool === TOOLS.RECT || item.type === ELEMENT_TYPES.RECT) {\r\n        const [p0, p1] = item.points;\r\n        drawRect(ctx, p0.x, p0.y, p1.x, p1.y, item.color, item.width);\r\n      } else if (item.tool === TOOLS.CIRCLE || item.type === ELEMENT_TYPES.CIRCLE) {\r\n        if (item.center && item.radius) {\r\n          drawCircle(ctx, item.center.x, item.center.y, item.radius, item.color, item.width);\r\n        }\r\n      } else if (item.type === ELEMENT_TYPES.IMAGE) {\r\n        // Check if image is already cached\r\n        let img = imageCache.current.get(item.src);\r\n        \r\n        if (img && img.complete) {\r\n          // Image is cached and loaded, draw immediately\r\n          ctx.drawImage(img, item.x, item.y, item.width, item.height);\r\n        } else if (!img) {\r\n          // Image not in cache, create and cache it\r\n          img = new Image();\r\n          img.onload = () => {\r\n            // Mark image as loaded and trigger a single redraw\r\n            requestAnimationFrame(() => redraw());\r\n          };\r\n          img.onerror = () => {\r\n            console.error('Failed to load image:', item.src);\r\n          };\r\n          imageCache.current.set(item.src, img);\r\n          img.src = item.src;\r\n        }\r\n        // If img exists but not complete, it's still loading - do nothing\r\n      }\r\n    });\r\n\r\n    // Draw selection boxes\r\n    selectedElements.forEach((element) => {\r\n      const bounds = getElementBounds(element);\r\n      if (bounds) {\r\n        drawSelectionBox(ctx, bounds, true);\r\n      }\r\n    });\r\n  }, [history, selectedElements]);\r\n\r\n  useEffect(() => {\r\n    redraw();\r\n  }, [redraw]);\r\n\r\n  // Cleanup image cache on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      imageCache.current.clear();\r\n    };\r\n  }, []);\r\n\r\n  const getMousePos = (e) => {\r\n    const rect = canvasRef.current.getBoundingClientRect();\r\n    return {\r\n      x: e.clientX - rect.left,\r\n      y: e.clientY - rect.top\r\n    };\r\n  };\r\n\r\n  const handlePointerDown = (e) => {\r\n    const { x, y } = getMousePos(e);\r\n    const point = { x, y };\r\n    \r\n    if (activeTool === TOOLS.SELECT) {\r\n      // Check if clicking on a resize handle first\r\n      let handleFound = false;\r\n      for (const element of selectedElements) {\r\n        const bounds = getElementBounds(element);\r\n        if (bounds) {\r\n          const handle = getResizeHandle(point, bounds);\r\n          if (handle) {\r\n            setResizeHandle(handle);\r\n            setIsResizing(true);\r\n            setStart(point);\r\n            setOriginalBounds(bounds); // Store original bounds for resize calculations\r\n            handleFound = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      \r\n      if (!handleFound) {\r\n        // Check if clicking on an element\r\n        let elementFound = null;\r\n        for (let i = history.length - 1; i >= 0; i--) {\r\n          if (isPointInElement(point, history[i])) {\r\n            elementFound = history[i];\r\n            break;\r\n          }\r\n        }\r\n        \r\n        if (elementFound) {\r\n          // Check if element is already selected\r\n          const isAlreadySelected = selectedElements.some(el => el.id === elementFound.id);\r\n          \r\n          if (e.ctrlKey || e.metaKey) {\r\n            // Multi-select\r\n            if (isAlreadySelected) {\r\n              setSelectedElements(prev => prev.filter(el => el.id !== elementFound.id));\r\n            } else {\r\n              setSelectedElements(prev => [...prev, elementFound]);\r\n            }\r\n          } else {\r\n            if (!isAlreadySelected) {\r\n              setSelectedElements([elementFound]);\r\n            }\r\n            setIsDragging(true);\r\n            setDragStart(point);\r\n            // Store original positions for consistent dragging\r\n            setDragStartPositions(selectedElements.map(el => ({\r\n              id: el.id,\r\n              originalElement: { ...el }\r\n            })));\r\n          }\r\n        } else {\r\n          // Clicked on empty space\r\n          setSelectedElements([]);\r\n        }\r\n      }\r\n    } else {\r\n      // Drawing tools\r\n      setDrawing(true);\r\n      setStart(point);\r\n      \r\n      if (activeTool === TOOLS.PEN) {\r\n        setCurrentStroke([point]);\r\n      }\r\n    }\r\n  };\r\n\r\n  const handlePointerMove = (e) => {\r\n    const { x, y } = getMousePos(e);\r\n    const point = { x, y };\r\n    \r\n    // Update cursor based on what's under the mouse\r\n    if (activeTool === TOOLS.SELECT && !isDragging && !isResizing) {\r\n      let cursorStyle = 'default';\r\n      \r\n      // Check for resize handles\r\n      for (const element of selectedElements) {\r\n        const bounds = getElementBounds(element);\r\n        if (bounds) {\r\n          const handle = getResizeHandle(point, bounds);\r\n          if (handle) {\r\n            const cursors = {\r\n              'nw': 'nw-resize', 'n': 'n-resize', 'ne': 'ne-resize',\r\n              'w': 'w-resize', 'e': 'e-resize',\r\n              'sw': 'sw-resize', 's': 's-resize', 'se': 'se-resize'\r\n            };\r\n            cursorStyle = cursors[handle];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Check for elements under cursor\r\n      if (cursorStyle === 'default') {\r\n        for (let i = history.length - 1; i >= 0; i--) {\r\n          if (isPointInElement(point, history[i])) {\r\n            cursorStyle = 'pointer';\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      \r\n      canvasRef.current.style.cursor = cursorStyle;\r\n    } else if (activeTool !== TOOLS.SELECT) {\r\n      canvasRef.current.style.cursor = 'crosshair';\r\n    }\r\n    \r\n    // Handle different interaction modes\r\n    if (isResizing && selectedElements.length > 0 && originalBounds) {\r\n      // Resize selected elements\r\n      const dx = x - start.x;\r\n      const dy = y - start.y;\r\n      \r\n      const updatedHistory = history.map(element => {\r\n        const selected = selectedElements.find(sel => sel.id === element.id);\r\n        if (!selected) return element;\r\n        \r\n        // Use the stored original bounds for consistent resize calculations\r\n        return resizeElement(element, resizeHandle, dx, dy, originalBounds);\r\n      });\r\n      \r\n      setHistory(updatedHistory);\r\n      \r\n      // Update selectedElements to match the resized elements\r\n      const updatedSelected = selectedElements.map(selected => {\r\n        const updated = updatedHistory.find(el => el.id === selected.id);\r\n        return updated || selected;\r\n      });\r\n      setSelectedElements(updatedSelected);\r\n      \r\n    } else if (isDragging && selectedElements.length > 0 && dragStartPositions) {\r\n      // Drag selected elements using original positions as reference\r\n      const dx = x - dragStart.x;\r\n      const dy = y - dragStart.y;\r\n      \r\n      const updatedHistory = history.map(element => {\r\n        const dragStartPos = dragStartPositions.find(pos => pos.id === element.id);\r\n        if (!dragStartPos) return element;\r\n        \r\n        const originalElement = dragStartPos.originalElement;\r\n        \r\n        // Apply drag offset to original positions\r\n        if (originalElement.type === ELEMENT_TYPES.IMAGE) {\r\n          return {\r\n            ...element,\r\n            x: originalElement.x + dx,\r\n            y: originalElement.y + dy\r\n          };\r\n        }\r\n        \r\n        if (originalElement.points) {\r\n          return {\r\n            ...element,\r\n            points: originalElement.points.map(p => ({ \r\n              x: p.x + dx, \r\n              y: p.y + dy \r\n            }))\r\n          };\r\n        }\r\n        \r\n        if (originalElement.center) {\r\n          return {\r\n            ...element,\r\n            center: { \r\n              x: originalElement.center.x + dx, \r\n              y: originalElement.center.y + dy \r\n            }\r\n          };\r\n        }\r\n        \r\n        return element;\r\n      });\r\n      \r\n      setHistory(updatedHistory);\r\n      \r\n      // Update selectedElements to match the moved elements\r\n      const updatedSelected = selectedElements.map(selected => {\r\n        const updated = updatedHistory.find(el => el.id === selected.id);\r\n        return updated || selected;\r\n      });\r\n      setSelectedElements(updatedSelected);\r\n      \r\n    } else if (drawing && activeTool !== TOOLS.SELECT) {\r\n      // Drawing mode\r\n      if (activeTool === TOOLS.PEN) {\r\n        setCurrentStroke(prev => [...prev, point]);\r\n        const ctx = canvasRef.current.getContext('2d');\r\n        if (currentStroke.length > 0) {\r\n          const lastPoint = currentStroke[currentStroke.length - 1];\r\n          drawLine(ctx, lastPoint.x, lastPoint.y, x, y, color, lineWidth);\r\n        }\r\n      } else {\r\n        // Preview shape\r\n        redraw();\r\n        const ctx = canvasRef.current.getContext('2d');\r\n        \r\n        if (activeTool === TOOLS.LINE && start) {\r\n          drawLine(ctx, start.x, start.y, x, y, color, lineWidth);\r\n        } else if (activeTool === TOOLS.RECT && start) {\r\n          drawRect(ctx, start.x, start.y, x, y, color, lineWidth);\r\n        } else if (activeTool === TOOLS.CIRCLE && start) {\r\n          const radius = Math.hypot(x - start.x, y - start.y);\r\n          drawCircle(ctx, start.x, start.y, radius, color, lineWidth);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // Helper function to resize an element\r\n  const resizeElement = (element, handle, dx, dy, originalBounds) => {\r\n    if (element.type === ELEMENT_TYPES.IMAGE) {\r\n      const newElement = { ...element };\r\n      switch (handle) {\r\n        case 'se': // bottom-right\r\n          newElement.width = Math.max(20, originalBounds.width + dx);\r\n          newElement.height = Math.max(20, originalBounds.height + dy);\r\n          break;\r\n        case 'sw': // bottom-left\r\n          newElement.x = originalBounds.x + dx;\r\n          newElement.width = Math.max(20, originalBounds.width - dx);\r\n          newElement.height = Math.max(20, originalBounds.height + dy);\r\n          break;\r\n        case 'ne': // top-right\r\n          newElement.width = Math.max(20, originalBounds.width + dx);\r\n          newElement.y = originalBounds.y + dy;\r\n          newElement.height = Math.max(20, originalBounds.height - dy);\r\n          break;\r\n        case 'nw': // top-left\r\n          newElement.x = originalBounds.x + dx;\r\n          newElement.y = originalBounds.y + dy;\r\n          newElement.width = Math.max(20, originalBounds.width - dx);\r\n          newElement.height = Math.max(20, originalBounds.height - dy);\r\n          break;\r\n        case 'n': // top-center\r\n          newElement.y = originalBounds.y + dy;\r\n          newElement.height = Math.max(20, originalBounds.height - dy);\r\n          break;\r\n        case 's': // bottom-center\r\n          newElement.height = Math.max(20, originalBounds.height + dy);\r\n          break;\r\n        case 'e': // middle-right\r\n          newElement.width = Math.max(20, originalBounds.width + dx);\r\n          break;\r\n        case 'w': // middle-left\r\n          newElement.x = originalBounds.x + dx;\r\n          newElement.width = Math.max(20, originalBounds.width - dx);\r\n          break;\r\n      }\r\n      return newElement;\r\n    }\r\n    \r\n    // For rectangles, simplify the logic\r\n    if (element.tool === TOOLS.RECT || element.type === ELEMENT_TYPES.RECT) {\r\n      const newElement = { ...element };\r\n      \r\n      // Calculate new bounds\r\n      let newX = originalBounds.x;\r\n      let newY = originalBounds.y;\r\n      let newWidth = originalBounds.width;\r\n      let newHeight = originalBounds.height;\r\n      \r\n      switch (handle) {\r\n        case 'nw': // top-left\r\n          newX = originalBounds.x + dx;\r\n          newY = originalBounds.y + dy;\r\n          newWidth = Math.max(20, originalBounds.width - dx);\r\n          newHeight = Math.max(20, originalBounds.height - dy);\r\n          break;\r\n        case 'n': // top-center\r\n          newY = originalBounds.y + dy;\r\n          newHeight = Math.max(20, originalBounds.height - dy);\r\n          break;\r\n        case 'ne': // top-right\r\n          newY = originalBounds.y + dy;\r\n          newWidth = Math.max(20, originalBounds.width + dx);\r\n          newHeight = Math.max(20, originalBounds.height - dy);\r\n          break;\r\n        case 'e': // middle-right\r\n          newWidth = Math.max(20, originalBounds.width + dx);\r\n          break;\r\n        case 'se': // bottom-right\r\n          newWidth = Math.max(20, originalBounds.width + dx);\r\n          newHeight = Math.max(20, originalBounds.height + dy);\r\n          break;\r\n        case 's': // bottom-center\r\n          newHeight = Math.max(20, originalBounds.height + dy);\r\n          break;\r\n        case 'sw': // bottom-left\r\n          newX = originalBounds.x + dx;\r\n          newWidth = Math.max(20, originalBounds.width - dx);\r\n          newHeight = Math.max(20, originalBounds.height + dy);\r\n          break;\r\n        case 'w': // middle-left\r\n          newX = originalBounds.x + dx;\r\n          newWidth = Math.max(20, originalBounds.width - dx);\r\n          break;\r\n      }\r\n      \r\n      // Convert back to points\r\n      newElement.points = [\r\n        { x: newX, y: newY },\r\n        { x: newX + newWidth, y: newY + newHeight }\r\n      ];\r\n      \r\n      return newElement;\r\n    }\r\n    \r\n    // Handle lines\r\n    if (element.tool === TOOLS.LINE || element.type === ELEMENT_TYPES.LINE) {\r\n      const newElement = { ...element };\r\n      const [p0, p1] = element.points;\r\n      \r\n      // Calculate new bounds\r\n      let newX = originalBounds.x;\r\n      let newY = originalBounds.y;\r\n      let newWidth = originalBounds.width;\r\n      let newHeight = originalBounds.height;\r\n      \r\n      switch (handle) {\r\n        case 'nw': // top-left\r\n          newX = originalBounds.x + dx;\r\n          newY = originalBounds.y + dy;\r\n          newWidth = Math.max(1, originalBounds.width - dx);\r\n          newHeight = Math.max(1, originalBounds.height - dy);\r\n          break;\r\n        case 'n': // top-center\r\n          newY = originalBounds.y + dy;\r\n          newHeight = Math.max(1, originalBounds.height - dy);\r\n          break;\r\n        case 'ne': // top-right\r\n          newY = originalBounds.y + dy;\r\n          newWidth = Math.max(1, originalBounds.width + dx);\r\n          newHeight = Math.max(1, originalBounds.height - dy);\r\n          break;\r\n        case 'e': // middle-right\r\n          newWidth = Math.max(1, originalBounds.width + dx);\r\n          break;\r\n        case 'se': // bottom-right\r\n          newWidth = Math.max(1, originalBounds.width + dx);\r\n          newHeight = Math.max(1, originalBounds.height + dy);\r\n          break;\r\n        case 's': // bottom-center\r\n          newHeight = Math.max(1, originalBounds.height + dy);\r\n          break;\r\n        case 'sw': // bottom-left\r\n          newX = originalBounds.x + dx;\r\n          newWidth = Math.max(1, originalBounds.width - dx);\r\n          newHeight = Math.max(1, originalBounds.height + dy);\r\n          break;\r\n        case 'w': // middle-left\r\n          newX = originalBounds.x + dx;\r\n          newWidth = Math.max(1, originalBounds.width - dx);\r\n          break;\r\n      }\r\n      \r\n      // Convert back to points\r\n      newElement.points = [\r\n        { x: newX, y: newY },\r\n        { x: newX + newWidth, y: newY + newHeight }\r\n      ];\r\n      \r\n      return newElement;\r\n    }\r\n    \r\n    // Handle freehand drawings (pen)\r\n    if (element.tool === TOOLS.PEN || element.type === ELEMENT_TYPES.PEN) {\r\n      const newElement = { ...element };\r\n      \r\n      if (!element.points || element.points.length === 0) {\r\n        return element;\r\n      }\r\n      \r\n      // Apply dampening factor to make resizing less sensitive\r\n      const dampening = 0.1; // 90% reduction - very fine control\r\n      const dampedDx = dx * dampening;\r\n      const dampedDy = dy * dampening;\r\n      \r\n      // Calculate new bounds based on handle with dampened movement\r\n      let newX = originalBounds.x;\r\n      let newY = originalBounds.y;\r\n      let newWidth = originalBounds.width;\r\n      let newHeight = originalBounds.height;\r\n      \r\n      switch (handle) {\r\n        case 'nw': // top-left\r\n          newX = originalBounds.x + dampedDx;\r\n          newY = originalBounds.y + dampedDy;\r\n          newWidth = Math.max(10, originalBounds.width - dampedDx);\r\n          newHeight = Math.max(10, originalBounds.height - dampedDy);\r\n          break;\r\n        case 'n': // top-center\r\n          newY = originalBounds.y + dampedDy;\r\n          newHeight = Math.max(10, originalBounds.height - dampedDy);\r\n          break;\r\n        case 'ne': // top-right\r\n          newY = originalBounds.y + dampedDy;\r\n          newWidth = Math.max(10, originalBounds.width + dampedDx);\r\n          newHeight = Math.max(10, originalBounds.height - dampedDy);\r\n          break;\r\n        case 'e': // middle-right\r\n          newWidth = Math.max(10, originalBounds.width + dampedDx);\r\n          break;\r\n        case 'se': // bottom-right\r\n          newWidth = Math.max(10, originalBounds.width + dampedDx);\r\n          newHeight = Math.max(10, originalBounds.height + dampedDy);\r\n          break;\r\n        case 's': // bottom-center\r\n          newHeight = Math.max(10, originalBounds.height + dampedDy);\r\n          break;\r\n        case 'sw': // bottom-left\r\n          newX = originalBounds.x + dampedDx;\r\n          newWidth = Math.max(10, originalBounds.width - dampedDx);\r\n          newHeight = Math.max(10, originalBounds.height + dampedDy);\r\n          break;\r\n        case 'w': // middle-left\r\n          newX = originalBounds.x + dampedDx;\r\n          newWidth = Math.max(10, originalBounds.width - dampedDx);\r\n          break;\r\n      }\r\n      \r\n      // Calculate scaling factors (now based on dampened movement)\r\n      const scaleX = originalBounds.width > 0 ? newWidth / originalBounds.width : 1;\r\n      const scaleY = originalBounds.height > 0 ? newHeight / originalBounds.height : 1;\r\n      \r\n      // Transform all points\r\n      newElement.points = element.points.map(point => {\r\n        const relativeX = point.x - originalBounds.x;\r\n        const relativeY = point.y - originalBounds.y;\r\n        \r\n        return {\r\n          x: newX + (relativeX * scaleX),\r\n          y: newY + (relativeY * scaleY)\r\n        };\r\n      });\r\n      \r\n      return newElement;\r\n    }\r\n    \r\n    // Handle circles\r\n    if (element.tool === TOOLS.CIRCLE || element.type === ELEMENT_TYPES.CIRCLE) {\r\n      const newElement = { ...element };\r\n      \r\n      switch (handle) {\r\n        case 'se':\r\n        case 'ne':\r\n        case 'sw':\r\n        case 'nw':\r\n          // For corners, adjust radius based on distance from center\r\n          const newRadius = Math.max(10, originalBounds.width / 2 + (handle.includes('e') ? dx : -dx));\r\n          newElement.radius = newRadius;\r\n          break;\r\n        case 'n':\r\n        case 's':\r\n          const newRadiusY = Math.max(10, originalBounds.height / 2 + (handle === 's' ? dy : -dy));\r\n          newElement.radius = newRadiusY;\r\n          break;\r\n        case 'e':\r\n        case 'w':\r\n          const newRadiusX = Math.max(10, originalBounds.width / 2 + (handle === 'e' ? dx : -dx));\r\n          newElement.radius = newRadiusX;\r\n          break;\r\n      }\r\n      return newElement;\r\n    }\r\n    \r\n    return element;\r\n  };\r\n\r\n  // Helper function to move an element\r\n  const moveElement = (element, dx, dy) => {\r\n    if (element.type === ELEMENT_TYPES.IMAGE) {\r\n      return {\r\n        ...element,\r\n        x: element.x + dx,\r\n        y: element.y + dy\r\n      };\r\n    }\r\n    \r\n    if (element.points) {\r\n      return {\r\n        ...element,\r\n        points: element.points.map(p => ({ x: p.x + dx, y: p.y + dy }))\r\n      };\r\n    }\r\n    \r\n    if (element.center) {\r\n      return {\r\n        ...element,\r\n        center: { x: element.center.x + dx, y: element.center.y + dy }\r\n      };\r\n    }\r\n    \r\n    return element;\r\n  };\r\n\r\n  const handlePointerUp = (e) => {\r\n    const { x, y } = getMousePos(e);\r\n    \r\n    if (isResizing) {\r\n      setIsResizing(false);\r\n      setResizeHandle(null);\r\n      setOriginalBounds(null); // Reset original bounds\r\n    } else if (isDragging) {\r\n      setIsDragging(false);\r\n      setDragStart(null);\r\n      setDragStartPositions(null);\r\n    } else if (drawing && activeTool !== TOOLS.SELECT) {\r\n      setDrawing(false);\r\n      \r\n      let element = null;\r\n      \r\n      if (activeTool === TOOLS.PEN) {\r\n        element = {\r\n          id: generateId(),\r\n          tool: TOOLS.PEN,\r\n          type: ELEMENT_TYPES.PEN,\r\n          points: [...currentStroke, { x, y }],\r\n          color,\r\n          width: lineWidth\r\n        };\r\n        setCurrentStroke([]);\r\n      } else if (activeTool === TOOLS.LINE) {\r\n        element = {\r\n          id: generateId(),\r\n          tool: TOOLS.LINE,\r\n          type: ELEMENT_TYPES.LINE,\r\n          points: [start, { x, y }],\r\n          color,\r\n          width: lineWidth\r\n        };\r\n      } else if (activeTool === TOOLS.RECT) {\r\n        element = {\r\n          id: generateId(),\r\n          tool: TOOLS.RECT,\r\n          type: ELEMENT_TYPES.RECT,\r\n          points: [start, { x, y }],\r\n          color,\r\n          width: lineWidth\r\n        };\r\n      } else if (activeTool === TOOLS.CIRCLE) {\r\n        const radius = Math.hypot(x - start.x, y - start.y);\r\n        element = {\r\n          id: generateId(),\r\n          tool: TOOLS.CIRCLE,\r\n          type: ELEMENT_TYPES.CIRCLE,\r\n          center: start,\r\n          radius,\r\n          color,\r\n          width: lineWidth\r\n        };\r\n      }\r\n      \r\n      if (element) {\r\n        setHistory(prev => [...prev, element]);\r\n        setSelectedElements([element]); // Auto-select newly created element\r\n      }\r\n    }\r\n    \r\n    setStart(null);\r\n  };\r\n\r\n  const handleUndo = () => {\r\n    setHistory(prev => prev.slice(0, -1));\r\n    setSelectedElements([]);\r\n  };\r\n\r\n  const handleClear = () => {\r\n    setHistory([]);\r\n    setSelectedElements([]);\r\n  };\r\n\r\n  const handleDelete = () => {\r\n    if (selectedElements.length > 0) {\r\n      const selectedIds = selectedElements.map(el => el.id);\r\n      setHistory(prev => prev.filter(el => !selectedIds.includes(el.id)));\r\n      setSelectedElements([]);\r\n    }\r\n  };\r\n\r\n  // Handle keyboard events\r\n  const handleKeyDown = useCallback((e) => {\r\n    if (e.key === 'Delete' || e.key === 'Backspace') {\r\n      handleDelete();\r\n      e.preventDefault();\r\n    } else if (e.key === 'Escape') {\r\n      setSelectedElements([]);\r\n    } else if (e.ctrlKey || e.metaKey) {\r\n      if (e.key === 'a') {\r\n        setSelectedElements([...history]);\r\n        e.preventDefault();\r\n      } else if (e.key === 'z') {\r\n        handleUndo();\r\n        e.preventDefault();\r\n      }\r\n    }\r\n  }, [history, selectedElements]);\r\n\r\n  // Add keyboard event listeners\r\n  useEffect(() => {\r\n    document.addEventListener('keydown', handleKeyDown);\r\n    return () => {\r\n      document.removeEventListener('keydown', handleKeyDown);\r\n    };\r\n  }, [handleKeyDown]);\r\n\r\n  return (\r\n    <div className=\"w-full h-full bg-gray-100 rounded-lg p-4\">\r\n      <div className=\"mb-4 flex gap-4 items-center flex-wrap\">\r\n        <input\r\n          type=\"color\"\r\n          value={color}\r\n          onChange={(e) => setColor(e.target.value)}\r\n          className=\"w-10 h-10 border-none rounded cursor-pointer\"\r\n        />\r\n        <input\r\n          type=\"range\"\r\n          min=\"1\"\r\n          max=\"20\"\r\n          value={lineWidth}\r\n          onChange={(e) => setLineWidth(Number(e.target.value))}\r\n          className=\"w-20\"\r\n        />\r\n        \r\n        <button\r\n          onClick={() => fileInputRef.current.click()}\r\n          className=\"px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600\"\r\n        >\r\n          Upload Image\r\n        </button>\r\n        \r\n        <input\r\n          ref={fileInputRef}\r\n          type=\"file\"\r\n          accept=\"image/*\"\r\n          onChange={(e) => handleImageUpload(e.target.files[0])}\r\n          className=\"hidden\"\r\n        />\r\n        \r\n        <button\r\n          onClick={handleUndo}\r\n          disabled={history.length === 0}\r\n          className=\"px-3 py-1 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-50\"\r\n        >\r\n          Undo\r\n        </button>\r\n        <button\r\n          onClick={handleClear}\r\n          className=\"px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600\"\r\n        >\r\n          Clear\r\n        </button>\r\n        \r\n        {selectedElements.length > 0 && (\r\n          <>\r\n            <button\r\n              onClick={handleDelete}\r\n              className=\"px-3 py-1 bg-red-600 text-white rounded hover:bg-red-700\"\r\n            >\r\n              Delete ({selectedElements.length})\r\n            </button>\r\n            <span className=\"text-sm text-gray-600\">\r\n              {selectedElements.length} selected\r\n            </span>\r\n          </>\r\n        )}\r\n      </div>\r\n      \r\n      <div className=\"mb-2 text-sm text-gray-600\">\r\n        {activeTool === TOOLS.SELECT ? (\r\n          <span>Selection Mode - Click to select, drag to move, use handles to resize. Ctrl+Click for multi-select. Paste images with Ctrl+V</span>\r\n        ) : (\r\n          <span>Drawing Mode - {activeTool}</span>\r\n        )}\r\n      </div>\r\n      \r\n      <canvas\r\n        ref={canvasRef}\r\n        width={CANVAS_WIDTH}\r\n        height={CANVAS_HEIGHT}\r\n        className=\"border border-gray-300 bg-white\"\r\n        onPointerDown={handlePointerDown}\r\n        onPointerMove={handlePointerMove}\r\n        onPointerUp={handlePointerUp}\r\n        onPointerLeave={handlePointerUp}\r\n        style={{ cursor: activeTool === TOOLS.SELECT ? 'default' : 'crosshair' }}\r\n      />\r\n    </div>\r\n  );\r\n});\r\n\r\nCanvas.displayName = 'Canvas';\r\n\r\nexport default Canvas;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}